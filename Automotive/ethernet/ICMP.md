


# [Internet Control Message Protocol](https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol)
[RFC792](https://www.rfc-editor.org/info/rfc792)


## CRC

[Internet checksum (RFC 1071)](https://en.wikipedia.org/wiki/Internet_checksum) for error checking, calculated from the ICMP header and data with value 0 substituted for this field.

**Examples**    
**Calculating the IPv4 header checksum**

Take the following truncated excerpt of an IPv4 packet. The header is shown in bold and the checksum is underlined.

**4500** **0073** **0000** **4000** **4011** ***_b861_*** **c0a8** **0001**   
**c0a8** **00c7** 0035 e97c 005f 279f 1e4b 8180

For ones' complement addition, each time a carry occurs, we must add a 1 to the sum.[7] A carry check and correction can be performed with each addition or as a post-process after all additions. If another carry is generated by the correction, another 1 is added to the sum.

To calculate the checksum, we can first calculate the sum of each 16 bit value within the header, skipping only the checksum field itself. Note that these values are in hexadecimal notation.

Initial addition: `4500 + 0073 + 0000 + 4000 + 4011 + c0a8 + 0001 + c0a8 + 00c7 = 2479c`

Carry addition is then made by adding the fifth hexadecimal digit to the first 4 digits: `2 + 479c = 479e`

Only a single carry addition is ever necessary even for maximum length IPv4 header, since the carry addition will never itself generate another carry.

The checksum is then the ones' complement (bitwise NOT) of this result: ` NOT 479e = b861`

This checksum value is shown as underlined in the original IP packet header above.  
**Verifying the IPv4 header checksum**  
When verifying a checksum, the same procedure is used as above, except that the original header checksum is not omitted.
`4500 + 0073 + 0000 + 4000 + 4011 + b861 + c0a8 + 0001 + c0a8 + 00c7 = 2fffd`
Add the carry bits:
`fffd + 2 = ffff`
Taking the ones' complement (flipping every bit) yields 0000, which indicates that no error is detected. IP header checksum does not check for the correct order of 16 bit values within the header. 


